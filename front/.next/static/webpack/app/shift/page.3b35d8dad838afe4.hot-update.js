"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/shift/page",{

/***/ "(app-client)/./util/lib.ts":
/*!*********************!*\
  !*** ./util/lib.ts ***!
  \*********************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CreateCookie: function() { return /* binding */ CreateCookie; },\n/* harmony export */   GetCookie: function() { return /* binding */ GetCookie; },\n/* harmony export */   GetMonthArray: function() { return /* binding */ GetMonthArray; },\n/* harmony export */   GetYearDays: function() { return /* binding */ GetYearDays; },\n/* harmony export */   MONTH: function() { return /* binding */ MONTH; },\n/* harmony export */   hasChanged: function() { return /* binding */ hasChanged; }\n/* harmony export */ });\nconst MONTH_DAYS = [\n    31,\n    28,\n    31,\n    30,\n    31,\n    30,\n    31,\n    31,\n    30,\n    31,\n    30,\n    31\n];\nconst MONTHS = [\n    \"Janvier\",\n    \"F\\xe9vrier\",\n    \"Mars\",\n    \"Avril\",\n    \"Mai\",\n    \"Juin\",\n    \"Juillet\",\n    \"Ao\\xfbt\",\n    \"Septembre\",\n    \"Octobre\",\n    \"Novembre\",\n    \"D\\xe9cembre\"\n];\nconst GetYearDays = (year, month)=>{\n    if (month !== 1) {\n        return {\n            year,\n            monthDays: MONTH_DAYS[month],\n            month: MONTHS[month],\n            monthIndex: month\n        };\n    } else {\n        if (year % 4 === 0) {\n            if (year % 100 !== 0) {\n                return {\n                    year,\n                    monthDays: MONTH_DAYS[month] + 1,\n                    month: MONTHS[month],\n                    monthIndex: month\n                };\n            }\n            if (year % 100 === 0 && year % 400 === 0) {\n                return {\n                    year,\n                    monthDays: MONTH_DAYS[month] + 1,\n                    month: MONTHS[month],\n                    monthIndex: month\n                };\n            } else {\n                return {\n                    year,\n                    monthDays: MONTH_DAYS[month],\n                    month: MONTHS[month],\n                    monthIndex: month\n                };\n            }\n        } else {\n            return {\n                year,\n                monthDays: MONTH_DAYS[month],\n                month: MONTHS[month],\n                monthIndex: month\n            };\n        }\n    }\n};\nconst MONTH = [\n    \"Janvier\",\n    \"F\\xe9vrier\",\n    \"Mars\",\n    \"Avril\",\n    \"Mai\",\n    \"Juin\",\n    \"Juillet\",\n    \"Ao\\xfbt\",\n    \"Septembre\",\n    \"Octobre\",\n    \"Novembre\",\n    \"D\\xe9cembre\"\n];\n/**\r\n * \r\n * @param cookieName the name of cookie\r\n * @param value the value of \r\n * @param maxAge the age in seconds\r\n */ const CreateCookie = function(cookieName, value, maxAge) {\n    let path = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : \"/\", secure = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : true;\n    document.cookie = \"\".concat(cookieName, \"=\").concat(value, \";path=\").concat(path, \";max-age=\").concat(maxAge);\n};\nconst GetCookie = (cookieName)=>{\n    const selectedCookie = document.cookie.split(\";\").map((cookie)=>cookie.trim()).filter((cookie)=>cookie.startsWith(cookieName))[0];\n    if (selectedCookie) {\n        return selectedCookie.split(\"=\")[1];\n    }\n    return undefined;\n};\nconst GetMonthArray = (year, monthIndex)=>{\n    const monthArray = new Array(42).fill(0);\n    const dayAmount = GetYearDays(year, monthIndex);\n    let to = \"\".concat(year, \"-\").concat(monthIndex < 10 ? \"0\" + monthIndex : monthIndex.toString(), \"-\").concat(dayAmount.monthDays.toString());\n    let from = \"\".concat(year, \"-\").concat(monthIndex < 10 ? \"0\" + monthIndex : monthIndex.toString(), \"-\").concat(dayAmount.monthDays.toString());\n    const calendar = monthArray.map((_, index)=>{\n        const thisMonth = new Date(year, monthIndex, 0);\n        let dayNumber = 0;\n        let isCurrentMonth = false;\n        let month = monthIndex;\n        if (index + 1 > thisMonth.getDay() && index - thisMonth.getDay() < dayAmount.monthDays) {\n            dayNumber = index + 1 - thisMonth.getDay();\n            isCurrentMonth = true;\n            month = monthIndex;\n        } else if (index - thisMonth.getDay() >= dayAmount.monthDays) {\n            const nextMonth = dayAmount.monthIndex === 11 ? GetYearDays(year + 1, 0) : GetYearDays(year, dayAmount.monthIndex + 1);\n            dayNumber = index + 1 - thisMonth.getDay() - dayAmount.monthDays;\n            isCurrentMonth = false;\n            month = nextMonth.monthIndex;\n            if (index === 41) {\n                to = \"\".concat(nextMonth.year, \"-\").concat(nextMonth.monthIndex + 1 < 10 ? \"0\" + (nextMonth.monthIndex + 1) : (nextMonth.monthIndex + 1).toString(), \"-\").concat(dayNumber < 10 ? \"0\" + dayNumber : dayNumber.toString());\n            }\n        } else {\n            const lastMonth = dayAmount.monthIndex === 0 ? GetYearDays(year - 1, 11) : GetYearDays(year, dayAmount.monthIndex - 1);\n            dayNumber = lastMonth.monthDays - thisMonth.getDay() + index + 1;\n            isCurrentMonth = false;\n            month = lastMonth.monthIndex;\n            if (index === 0) {\n                from = \"\".concat(lastMonth.year, \"-\").concat(lastMonth.monthIndex + 1 < 10 ? \"0\" + (lastMonth.monthIndex + 1) : (lastMonth.monthIndex + 1).toString(), \"-\").concat(dayNumber < 10 ? \"0\" + dayNumber : dayNumber.toString());\n            }\n        }\n        return {\n            isCurrentMonth,\n            dayNumber,\n            month\n        };\n    });\n    return {\n        calendar,\n        to,\n        from\n    };\n};\nconst hasChanged = (initialArray, compareTo, properties)=>{\n    for(let i = 0; i < initialArray.length; i++){\n        for(let x = 0; x < properties.length; x++){\n            if (initialArray[i][properties[x]] !== compareTo[i][properties[x]]) return true;\n        }\n    }\n    return false;\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QixVQUFVSSxNQUFNLEtBQUtMLFFBQU87WUFDOURJLGlCQUFpQjtZQUNqQmxDLFFBQVFxQyxVQUFVbkMsVUFBVTtZQUM1QixJQUFJNEIsVUFBVSxHQUFFO2dCQUNaSCxPQUFPLEdBQXFCLE9BQWxCVSxVQUFVdEMsSUFBSSxFQUFDLEtBQXlHa0MsT0FBdEcsVUFBVy9CLFVBQVUsR0FBQyxJQUFLLEtBQUssTUFBS21DLENBQUFBLFVBQVVuQyxVQUFVLEdBQUMsS0FBSyxDQUFDbUMsVUFBVW5DLFVBQVUsR0FBQyxHQUFHd0IsUUFBUSxJQUFHLEtBQXlELE9BQXRETyxZQUFZLEtBQUssTUFBSUEsWUFBWUEsVUFBVVAsUUFBUTtZQUN6TDtRQUNKO1FBQ0EsT0FBTztZQUFDUTtZQUFnQkQ7WUFBV2pDO1FBQUs7SUFDNUM7SUFDQSxPQUFPO1FBQUM0QjtRQUFVSDtRQUFJRTtJQUFJO0FBQzlCLEVBQUM7QUFNTSxNQUFNVyxhQUFhLENBQTBDQyxjQUFzQkMsV0FBbUJDO0lBQ3pHLElBQUksSUFBSUMsSUFBSSxHQUFHQSxJQUFJSCxhQUFhSSxNQUFNLEVBQUVELElBQUk7UUFDeEMsSUFBSSxJQUFJRSxJQUFJLEdBQUdBLElBQUlILFdBQVdFLE1BQU0sRUFBRUMsSUFBSTtZQUN0QyxJQUFHTCxZQUFZLENBQUNHLEVBQUUsQ0FBQ0QsVUFBVSxDQUFDRyxFQUFFLENBQUMsS0FBS0osU0FBUyxDQUFDRSxFQUFFLENBQUNELFVBQVUsQ0FBQ0csRUFBRSxDQUFDLEVBQUUsT0FBTztRQUM5RTtJQUNKO0lBQ0EsT0FBTztBQUNYLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vdXRpbC9saWIudHM/YjA1ZCJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBNT05USF9EQVlTID0gWzMxLCAyOCwgMzEsIDMwLCAzMSwgMzAsIDMxLCAzMSwgMzAsIDMxLCAzMCwgMzFdXHJcbmNvbnN0IE1PTlRIUyA9IFtcIkphbnZpZXJcIiwgXCJGw6l2cmllclwiLCBcIk1hcnNcIiwgXCJBdnJpbFwiLCBcIk1haVwiLCBcIkp1aW5cIiwgXCJKdWlsbGV0XCIsIFwiQW/Du3RcIiwgXCJTZXB0ZW1icmVcIiwgXCJPY3RvYnJlXCIsIFwiTm92ZW1icmVcIiwgXCJEw6ljZW1icmVcIl1cclxuXHJcbmV4cG9ydCBjb25zdCBHZXRZZWFyRGF5cyA9ICh5ZWFyOiBudW1iZXIsIG1vbnRoOiBudW1iZXIpPT57XHJcblxyXG4gICAgaWYobW9udGggIT09IDEpe1xyXG4gICAgICAgIHJldHVybiB7eWVhciwgbW9udGhEYXlzOiBNT05USF9EQVlTW21vbnRoXSwgbW9udGg6IE1PTlRIU1ttb250aF0sIG1vbnRoSW5kZXg6IG1vbnRofVxyXG4gICAgfWVsc2V7XHJcbiAgICAgICAgaWYoeWVhciAlIDQgPT09IDApe1xyXG4gICAgICAgICAgICBpZih5ZWFyICUgMTAwICE9PSAwKXtcclxuICAgICAgICAgICAgICAgIHJldHVybiB7eWVhciwgbW9udGhEYXlzOiBNT05USF9EQVlTW21vbnRoXSsxLCBtb250aDogTU9OVEhTW21vbnRoXSwgbW9udGhJbmRleDogbW9udGh9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYoeWVhciAlIDEwMCA9PT0gMCAmJiB5ZWFyICUgNDAwID09PSAwKXtcclxuICAgICAgICAgICAgICAgIHJldHVybiB7eWVhciwgbW9udGhEYXlzOiBNT05USF9EQVlTW21vbnRoXSsxLCBtb250aDogTU9OVEhTW21vbnRoXSwgbW9udGhJbmRleDogbW9udGh9XHJcbiAgICAgICAgICAgIH1lbHNle1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHt5ZWFyLCBtb250aERheXM6IE1PTlRIX0RBWVNbbW9udGhdLCBtb250aDogTU9OVEhTW21vbnRoXSwgbW9udGhJbmRleDogbW9udGh9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9ZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7eWVhciwgbW9udGhEYXlzOiBNT05USF9EQVlTW21vbnRoXSwgbW9udGg6IE1PTlRIU1ttb250aF0sIG1vbnRoSW5kZXg6IG1vbnRofVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGNvbnN0IE1PTlRIID0gW1wiSmFudmllclwiLCBcIkbDqXZyaWVyXCIsIFwiTWFyc1wiLCBcIkF2cmlsXCIsIFwiTWFpXCIsIFwiSnVpblwiLCBcIkp1aWxsZXRcIiwgXCJBb8O7dFwiLCBcIlNlcHRlbWJyZVwiLCBcIk9jdG9icmVcIiwgXCJOb3ZlbWJyZVwiLCBcIkTDqWNlbWJyZVwiXVxyXG5cclxuLyoqXHJcbiAqIFxyXG4gKiBAcGFyYW0gY29va2llTmFtZSB0aGUgbmFtZSBvZiBjb29raWVcclxuICogQHBhcmFtIHZhbHVlIHRoZSB2YWx1ZSBvZiBcclxuICogQHBhcmFtIG1heEFnZSB0aGUgYWdlIGluIHNlY29uZHNcclxuICovXHJcbmV4cG9ydCBjb25zdCBDcmVhdGVDb29raWUgPSAoY29va2llTmFtZTogc3RyaW5nLCB2YWx1ZTogc3RyaW5nLCBtYXhBZ2U6IG51bWJlciwgcGF0aDogc3RyaW5nID0gXCIvXCIsIHNlY3VyZTogYm9vbGVhbiA9IHRydWUpPT57XHJcbiAgICBkb2N1bWVudC5jb29raWUgPSBgJHtjb29raWVOYW1lfT0ke3ZhbHVlfTtwYXRoPSR7cGF0aH07bWF4LWFnZT0ke21heEFnZX1gXHJcbn1cclxuXHJcbmV4cG9ydCBjb25zdCBHZXRDb29raWUgPSAoY29va2llTmFtZTogc3RyaW5nKTpzdHJpbmcgfCB1bmRlZmluZWQ9PntcclxuICAgIGNvbnN0IHNlbGVjdGVkQ29va2llID0gZG9jdW1lbnQuY29va2llLnNwbGl0KFwiO1wiKS5tYXAoY29va2llPT5jb29raWUudHJpbSgpKS5maWx0ZXIoY29va2llPT5jb29raWUuc3RhcnRzV2l0aChjb29raWVOYW1lKSlbMF1cclxuICAgIGlmKHNlbGVjdGVkQ29va2llKXtcclxuICAgICAgICByZXR1cm4gc2VsZWN0ZWRDb29raWUuc3BsaXQoXCI9XCIpWzFdXHJcbiAgICB9XHJcbiAgICByZXR1cm4gdW5kZWZpbmVkXHJcbn1cclxuXHJcbmludGVyZmFjZSBDYWxlbmRhckFycmF5e1xyXG4gICAgY2FsZW5kYXI6IHtpc0N1cnJlbnRNb250aDogYm9vbGVhbiwgZGF5TnVtYmVyOiBudW1iZXIsIG1vbnRoOiBudW1iZXJ9W10sXHJcbiAgICB0bzogc3RyaW5nXHJcbiAgICBmcm9tOiBzdHJpbmdcclxufSBcclxuXHJcbmV4cG9ydCBjb25zdCBHZXRNb250aEFycmF5ID0gKHllYXI6IG51bWJlciwgbW9udGhJbmRleDogbnVtYmVyKTpDYWxlbmRhckFycmF5PT57XHJcbiAgICBjb25zdCBtb250aEFycmF5ID0gbmV3IEFycmF5KDQyKS5maWxsKDApXHJcbiAgICBjb25zdCBkYXlBbW91bnQgPSBHZXRZZWFyRGF5cyh5ZWFyLCBtb250aEluZGV4KVxyXG4gICAgbGV0IHRvOiBzdHJpbmcgID0gYCR7eWVhcn0tJHttb250aEluZGV4IDwgMTAgPyBcIjBcIittb250aEluZGV4IDogbW9udGhJbmRleC50b1N0cmluZygpfS0ke2RheUFtb3VudC5tb250aERheXMudG9TdHJpbmcoKX1gXHJcbiAgICBsZXQgZnJvbTogc3RyaW5nID0gYCR7eWVhcn0tJHttb250aEluZGV4IDwgMTAgPyBcIjBcIittb250aEluZGV4IDogbW9udGhJbmRleC50b1N0cmluZygpfS0ke2RheUFtb3VudC5tb250aERheXMudG9TdHJpbmcoKX1gXHJcbiAgICBjb25zdCBjYWxlbmRhciA9IG1vbnRoQXJyYXkubWFwKChfLCBpbmRleCk6e2lzQ3VycmVudE1vbnRoOiBib29sZWFuLCBkYXlOdW1iZXI6IG51bWJlciwgbW9udGg6IG51bWJlcn09PntcclxuICAgICAgICBjb25zdCB0aGlzTW9udGggPSBuZXcgRGF0ZSh5ZWFyLCBtb250aEluZGV4LCAwKVxyXG4gICAgICAgIGxldCBkYXlOdW1iZXIgPSAwXHJcbiAgICAgICAgbGV0IGlzQ3VycmVudE1vbnRoID0gZmFsc2VcclxuICAgICAgICBsZXQgbW9udGggPSBtb250aEluZGV4XHJcbiAgICAgICAgaWYoaW5kZXgrMSA+IHRoaXNNb250aC5nZXREYXkoKSAmJiBpbmRleC10aGlzTW9udGguZ2V0RGF5KCkgPCBkYXlBbW91bnQubW9udGhEYXlzKXtcclxuICAgICAgICAgICAgZGF5TnVtYmVyID0gaW5kZXgrMS10aGlzTW9udGguZ2V0RGF5KClcclxuICAgICAgICAgICAgaXNDdXJyZW50TW9udGggPSB0cnVlXHJcbiAgICAgICAgICAgIG1vbnRoID0gbW9udGhJbmRleFxyXG4gICAgICAgIH1lbHNlIGlmKGluZGV4LXRoaXNNb250aC5nZXREYXkoKSA+PSBkYXlBbW91bnQubW9udGhEYXlzKXtcclxuICAgICAgICAgICAgY29uc3QgbmV4dE1vbnRoID0gZGF5QW1vdW50Lm1vbnRoSW5kZXggPT09IDExID8gR2V0WWVhckRheXMoeWVhcisxLCAwKSA6IEdldFllYXJEYXlzKHllYXIsIGRheUFtb3VudC5tb250aEluZGV4ICsgMSlcclxuICAgICAgICAgICAgZGF5TnVtYmVyID0gaW5kZXgrMSAtIHRoaXNNb250aC5nZXREYXkoKSAtIGRheUFtb3VudC5tb250aERheXNcclxuICAgICAgICAgICAgaXNDdXJyZW50TW9udGggPSBmYWxzZVxyXG4gICAgICAgICAgICBtb250aCA9IG5leHRNb250aC5tb250aEluZGV4XHJcbiAgICAgICAgICAgIGlmIChpbmRleCA9PT0gNDEpe1xyXG4gICAgICAgICAgICAgICAgdG8gPSBgJHtuZXh0TW9udGgueWVhcn0tJHsobmV4dE1vbnRoLm1vbnRoSW5kZXggKyAxKSA8IDEwID8gXCIwXCIrKG5leHRNb250aC5tb250aEluZGV4ICsgMSkgIDogKG5leHRNb250aC5tb250aEluZGV4ICsgMSkudG9TdHJpbmcoKX0tJHtkYXlOdW1iZXIgPCAxMCA/IFwiMFwiK2RheU51bWJlciA6IGRheU51bWJlci50b1N0cmluZygpfWBcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1lbHNle1xyXG4gICAgICAgICAgICBjb25zdCBsYXN0TW9udGggPSBkYXlBbW91bnQubW9udGhJbmRleCA9PT0gMCA/IEdldFllYXJEYXlzKHllYXItMSwgMTEpIDogR2V0WWVhckRheXMoeWVhciwgZGF5QW1vdW50Lm1vbnRoSW5kZXggLSAxKVxyXG4gICAgICAgICAgICBkYXlOdW1iZXIgPSBsYXN0TW9udGgubW9udGhEYXlzIC0gdGhpc01vbnRoLmdldERheSgpICsgaW5kZXggKzFcclxuICAgICAgICAgICAgaXNDdXJyZW50TW9udGggPSBmYWxzZVxyXG4gICAgICAgICAgICBtb250aCA9IGxhc3RNb250aC5tb250aEluZGV4XHJcbiAgICAgICAgICAgIGlmIChpbmRleCA9PT0gMCl7XHJcbiAgICAgICAgICAgICAgICBmcm9tID0gYCR7bGFzdE1vbnRoLnllYXJ9LSR7KGxhc3RNb250aC5tb250aEluZGV4KzEpIDwgMTAgPyBcIjBcIisobGFzdE1vbnRoLm1vbnRoSW5kZXgrMSkgOiAobGFzdE1vbnRoLm1vbnRoSW5kZXgrMSkudG9TdHJpbmcoKX0tJHtkYXlOdW1iZXIgPCAxMCA/IFwiMFwiK2RheU51bWJlciA6IGRheU51bWJlci50b1N0cmluZygpfWAgXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHtpc0N1cnJlbnRNb250aCwgZGF5TnVtYmVyLCBtb250aH0gICAgICAgICAgICBcclxuICAgIH0pXHJcbiAgICByZXR1cm4ge2NhbGVuZGFyLCB0bywgZnJvbX1cclxufVxyXG5cclxudHlwZSBZZXM8VCBleHRlbmRzIHt9PiA9IHtcclxuICAgIFtLZXkgaW4ga2V5b2YgVF06IGFueVxyXG59XHJcblxyXG5leHBvcnQgY29uc3QgaGFzQ2hhbmdlZCA9IDxUT2JqIGV4dGVuZHMge30sIEtleSBleHRlbmRzIGtleW9mIFRPYmo+KGluaXRpYWxBcnJheTogVE9ialtdLCBjb21wYXJlVG86IFRPYmpbXSwgcHJvcGVydGllczogS2V5W10pOmJvb2xlYW49PntcclxuICAgIGZvcihsZXQgaSA9IDA7IGkgPCBpbml0aWFsQXJyYXkubGVuZ3RoOyBpKyspe1xyXG4gICAgICAgIGZvcihsZXQgeCA9IDA7IHggPCBwcm9wZXJ0aWVzLmxlbmd0aDsgeCsrKXtcclxuICAgICAgICAgICAgaWYoaW5pdGlhbEFycmF5W2ldW3Byb3BlcnRpZXNbeF1dICE9PSBjb21wYXJlVG9baV1bcHJvcGVydGllc1t4XV0pIHJldHVybiB0cnVlXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZhbHNlXHJcbn1cclxuIl0sIm5hbWVzIjpbIk1PTlRIX0RBWVMiLCJNT05USFMiLCJHZXRZZWFyRGF5cyIsInllYXIiLCJtb250aCIsIm1vbnRoRGF5cyIsIm1vbnRoSW5kZXgiLCJNT05USCIsIkNyZWF0ZUNvb2tpZSIsImNvb2tpZU5hbWUiLCJ2YWx1ZSIsIm1heEFnZSIsInBhdGgiLCJzZWN1cmUiLCJkb2N1bWVudCIsImNvb2tpZSIsIkdldENvb2tpZSIsInNlbGVjdGVkQ29va2llIiwic3BsaXQiLCJtYXAiLCJ0cmltIiwiZmlsdGVyIiwic3RhcnRzV2l0aCIsInVuZGVmaW5lZCIsIkdldE1vbnRoQXJyYXkiLCJtb250aEFycmF5IiwiQXJyYXkiLCJmaWxsIiwiZGF5QW1vdW50IiwidG8iLCJ0b1N0cmluZyIsImZyb20iLCJjYWxlbmRhciIsIl8iLCJpbmRleCIsInRoaXNNb250aCIsIkRhdGUiLCJkYXlOdW1iZXIiLCJpc0N1cnJlbnRNb250aCIsImdldERheSIsIm5leHRNb250aCIsImxhc3RNb250aCIsImhhc0NoYW5nZWQiLCJpbml0aWFsQXJyYXkiLCJjb21wYXJlVG8iLCJwcm9wZXJ0aWVzIiwiaSIsImxlbmd0aCIsIngiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-client)/./util/lib.ts\n"));

/***/ })

});