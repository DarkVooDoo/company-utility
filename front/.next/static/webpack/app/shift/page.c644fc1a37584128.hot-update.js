"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/shift/page",{

/***/ "(app-client)/./util/lib.ts":
/*!*********************!*\
  !*** ./util/lib.ts ***!
  \*********************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CreateCookie: function() { return /* binding */ CreateCookie; },\n/* harmony export */   GetCookie: function() { return /* binding */ GetCookie; },\n/* harmony export */   GetMonthArray: function() { return /* binding */ GetMonthArray; },\n/* harmony export */   GetYearDays: function() { return /* binding */ GetYearDays; },\n/* harmony export */   MONTH: function() { return /* binding */ MONTH; },\n/* harmony export */   hasChanged: function() { return /* binding */ hasChanged; }\n/* harmony export */ });\nconst MONTH_DAYS = [\n    31,\n    28,\n    31,\n    30,\n    31,\n    30,\n    31,\n    31,\n    30,\n    31,\n    30,\n    31\n];\nconst MONTHS = [\n    \"Janvier\",\n    \"F\\xe9vrier\",\n    \"Mars\",\n    \"Avril\",\n    \"Mai\",\n    \"Juin\",\n    \"Juillet\",\n    \"Ao\\xfbt\",\n    \"Septembre\",\n    \"Octobre\",\n    \"Novembre\",\n    \"D\\xe9cembre\"\n];\nconst GetYearDays = (year, month)=>{\n    if (month !== 1) {\n        return {\n            year,\n            monthDays: MONTH_DAYS[month],\n            month: MONTHS[month],\n            monthIndex: month\n        };\n    } else {\n        if (year % 4 === 0) {\n            if (year % 100 !== 0) {\n                return {\n                    year,\n                    monthDays: MONTH_DAYS[month] + 1,\n                    month: MONTHS[month],\n                    monthIndex: month\n                };\n            }\n            if (year % 100 === 0 && year % 400 === 0) {\n                return {\n                    year,\n                    monthDays: MONTH_DAYS[month] + 1,\n                    month: MONTHS[month],\n                    monthIndex: month\n                };\n            } else {\n                return {\n                    year,\n                    monthDays: MONTH_DAYS[month],\n                    month: MONTHS[month],\n                    monthIndex: month\n                };\n            }\n        } else {\n            return {\n                year,\n                monthDays: MONTH_DAYS[month],\n                month: MONTHS[month],\n                monthIndex: month\n            };\n        }\n    }\n};\nconst MONTH = [\n    \"Janvier\",\n    \"F\\xe9vrier\",\n    \"Mars\",\n    \"Avril\",\n    \"Mai\",\n    \"Juin\",\n    \"Juillet\",\n    \"Ao\\xfbt\",\n    \"Septembre\",\n    \"Octobre\",\n    \"Novembre\",\n    \"D\\xe9cembre\"\n];\n/**\r\n * \r\n * @param cookieName the name of cookie\r\n * @param value the value of \r\n * @param maxAge the age in seconds\r\n */ const CreateCookie = function(cookieName, value, maxAge) {\n    let path = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : \"/\", secure = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : true;\n    document.cookie = \"\".concat(cookieName, \"=\").concat(value, \";path=\").concat(path, \";max-age=\").concat(maxAge);\n};\nconst GetCookie = (cookieName)=>{\n    const selectedCookie = document.cookie.split(\";\").map((cookie)=>cookie.trim()).filter((cookie)=>cookie.startsWith(cookieName))[0];\n    if (selectedCookie) {\n        return selectedCookie.split(\"=\")[1];\n    }\n    return undefined;\n};\nconst GetMonthArray = (year, monthIndex)=>{\n    const monthArray = new Array(42).fill(0);\n    const dayAmount = GetYearDays(year, monthIndex);\n    let to = \"\".concat(year, \"-\").concat(monthIndex < 10 ? \"0\" + monthIndex : monthIndex.toString(), \"-\").concat(dayAmount.monthDays.toString());\n    let from = \"\".concat(year, \"-\").concat(monthIndex < 10 ? \"0\" + monthIndex : monthIndex.toString(), \"-\").concat(dayAmount.monthDays.toString());\n    const calendar = monthArray.map((_, index)=>{\n        const thisMonth = new Date(year, monthIndex, 0);\n        let dayNumber = 0;\n        let isCurrentMonth = false;\n        let month = monthIndex;\n        if (index + 1 > thisMonth.getDay() && index - thisMonth.getDay() < dayAmount.monthDays) {\n            dayNumber = index + 1 - thisMonth.getDay();\n            isCurrentMonth = true;\n            month = monthIndex;\n        } else if (index - thisMonth.getDay() >= dayAmount.monthDays) {\n            const nextMonth = dayAmount.monthIndex === 11 ? GetYearDays(year + 1, 0) : GetYearDays(year, dayAmount.monthIndex + 1);\n            dayNumber = index + 1 - thisMonth.getDay() - dayAmount.monthDays;\n            isCurrentMonth = false;\n            month = nextMonth.monthIndex;\n            if (index === 41) {\n                to = \"\".concat(nextMonth.year, \"-\").concat(nextMonth.monthIndex + 1 < 10 ? \"0\" + (nextMonth.monthIndex + 1) : (nextMonth.monthIndex + 1).toString(), \"-\").concat(dayNumber < 10 ? \"0\" + dayNumber : dayNumber.toString());\n            }\n        } else {\n            const lastMonth = dayAmount.monthIndex === 0 ? GetYearDays(year - 1, 11) : GetYearDays(year, dayAmount.monthIndex - 1);\n            dayNumber = lastMonth.monthDays - thisMonth.getDay() + index + 1;\n            isCurrentMonth = false;\n            month = lastMonth.monthIndex;\n            if (index === 0) {\n                from = \"\".concat(lastMonth.year, \"-\").concat(lastMonth.monthIndex + 1 < 10 ? \"0\" + (lastMonth.monthIndex + 1) : (lastMonth.monthIndex + 1).toString(), \"-\").concat(dayNumber < 10 ? \"0\" + dayNumber : dayNumber.toString());\n            }\n        }\n        return {\n            isCurrentMonth,\n            dayNumber,\n            month\n        };\n    });\n    return {\n        calendar,\n        to,\n        from\n    };\n};\nconst hasChanged = (initialArray, compareTo, properties)=>{\n    const changes = [];\n    for(let i = 0; i < initialArray.length; i++){\n        for(let x = 0; x < properties.length; x++){\n            console.log(compareTo[i]);\n            if (initialArray[i][properties[x]] !== compareTo[i][properties[x]]) return [\n                true,\n                changes.push(compareTo[i])\n            ];\n        }\n    }\n    return [\n        false,\n        []\n    ];\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QixVQUFVSSxNQUFNLEtBQUtMLFFBQU87WUFDOURJLGlCQUFpQjtZQUNqQmxDLFFBQVFxQyxVQUFVbkMsVUFBVTtZQUM1QixJQUFJNEIsVUFBVSxHQUFFO2dCQUNaSCxPQUFPLEdBQXFCLE9BQWxCVSxVQUFVdEMsSUFBSSxFQUFDLEtBQXlHa0MsT0FBdEcsVUFBVy9CLFVBQVUsR0FBQyxJQUFLLEtBQUssTUFBS21DLENBQUFBLFVBQVVuQyxVQUFVLEdBQUMsS0FBSyxDQUFDbUMsVUFBVW5DLFVBQVUsR0FBQyxHQUFHd0IsUUFBUSxJQUFHLEtBQXlELE9BQXRETyxZQUFZLEtBQUssTUFBSUEsWUFBWUEsVUFBVVAsUUFBUTtZQUN6TDtRQUNKO1FBQ0EsT0FBTztZQUFDUTtZQUFnQkQ7WUFBV2pDO1FBQUs7SUFDNUM7SUFDQSxPQUFPO1FBQUM0QjtRQUFVSDtRQUFJRTtJQUFJO0FBQzlCLEVBQUM7QUFNTSxNQUFNVyxhQUFhLENBQTBDQyxjQUFzQkMsV0FBbUJDO0lBQ3pHLE1BQU1DLFVBQWUsRUFBRTtJQUN2QixJQUFJLElBQUlDLElBQUksR0FBR0EsSUFBSUosYUFBYUssTUFBTSxFQUFFRCxJQUFJO1FBQ3hDLElBQUksSUFBSUUsSUFBSSxHQUFHQSxJQUFJSixXQUFXRyxNQUFNLEVBQUVDLElBQUk7WUFDdENDLFFBQVFDLEdBQUcsQ0FBQ1AsU0FBUyxDQUFDRyxFQUFFO1lBQ3hCLElBQUdKLFlBQVksQ0FBQ0ksRUFBRSxDQUFDRixVQUFVLENBQUNJLEVBQUUsQ0FBQyxLQUFLTCxTQUFTLENBQUNHLEVBQUUsQ0FBQ0YsVUFBVSxDQUFDSSxFQUFFLENBQUMsRUFBRSxPQUFPO2dCQUFDO2dCQUFNSCxRQUFRTSxJQUFJLENBQUNSLFNBQVMsQ0FBQ0csRUFBRTthQUFFO1FBQ2hIO0lBQ0o7SUFDQSxPQUFPO1FBQUM7UUFBTyxFQUFFO0tBQUM7QUFDdEIsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi91dGlsL2xpYi50cz9iMDVkIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFNoaWZ0VHlwZXMgfSBmcm9tIFwiQC9jb21wb25lbnQvU2hpZnQvY29tcG9uZW50XCJcclxuXHJcbmNvbnN0IE1PTlRIX0RBWVMgPSBbMzEsIDI4LCAzMSwgMzAsIDMxLCAzMCwgMzEsIDMxLCAzMCwgMzEsIDMwLCAzMV1cclxuY29uc3QgTU9OVEhTID0gW1wiSmFudmllclwiLCBcIkbDqXZyaWVyXCIsIFwiTWFyc1wiLCBcIkF2cmlsXCIsIFwiTWFpXCIsIFwiSnVpblwiLCBcIkp1aWxsZXRcIiwgXCJBb8O7dFwiLCBcIlNlcHRlbWJyZVwiLCBcIk9jdG9icmVcIiwgXCJOb3ZlbWJyZVwiLCBcIkTDqWNlbWJyZVwiXVxyXG5cclxuZXhwb3J0IGNvbnN0IEdldFllYXJEYXlzID0gKHllYXI6IG51bWJlciwgbW9udGg6IG51bWJlcik9PntcclxuXHJcbiAgICBpZihtb250aCAhPT0gMSl7XHJcbiAgICAgICAgcmV0dXJuIHt5ZWFyLCBtb250aERheXM6IE1PTlRIX0RBWVNbbW9udGhdLCBtb250aDogTU9OVEhTW21vbnRoXSwgbW9udGhJbmRleDogbW9udGh9XHJcbiAgICB9ZWxzZXtcclxuICAgICAgICBpZih5ZWFyICUgNCA9PT0gMCl7XHJcbiAgICAgICAgICAgIGlmKHllYXIgJSAxMDAgIT09IDApe1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHt5ZWFyLCBtb250aERheXM6IE1PTlRIX0RBWVNbbW9udGhdKzEsIG1vbnRoOiBNT05USFNbbW9udGhdLCBtb250aEluZGV4OiBtb250aH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZih5ZWFyICUgMTAwID09PSAwICYmIHllYXIgJSA0MDAgPT09IDApe1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHt5ZWFyLCBtb250aERheXM6IE1PTlRIX0RBWVNbbW9udGhdKzEsIG1vbnRoOiBNT05USFNbbW9udGhdLCBtb250aEluZGV4OiBtb250aH1cclxuICAgICAgICAgICAgfWVsc2V7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ge3llYXIsIG1vbnRoRGF5czogTU9OVEhfREFZU1ttb250aF0sIG1vbnRoOiBNT05USFNbbW9udGhdLCBtb250aEluZGV4OiBtb250aH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1lbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHt5ZWFyLCBtb250aERheXM6IE1PTlRIX0RBWVNbbW9udGhdLCBtb250aDogTU9OVEhTW21vbnRoXSwgbW9udGhJbmRleDogbW9udGh9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgY29uc3QgTU9OVEggPSBbXCJKYW52aWVyXCIsIFwiRsOpdnJpZXJcIiwgXCJNYXJzXCIsIFwiQXZyaWxcIiwgXCJNYWlcIiwgXCJKdWluXCIsIFwiSnVpbGxldFwiLCBcIkFvw7t0XCIsIFwiU2VwdGVtYnJlXCIsIFwiT2N0b2JyZVwiLCBcIk5vdmVtYnJlXCIsIFwiRMOpY2VtYnJlXCJdXHJcblxyXG4vKipcclxuICogXHJcbiAqIEBwYXJhbSBjb29raWVOYW1lIHRoZSBuYW1lIG9mIGNvb2tpZVxyXG4gKiBAcGFyYW0gdmFsdWUgdGhlIHZhbHVlIG9mIFxyXG4gKiBAcGFyYW0gbWF4QWdlIHRoZSBhZ2UgaW4gc2Vjb25kc1xyXG4gKi9cclxuZXhwb3J0IGNvbnN0IENyZWF0ZUNvb2tpZSA9IChjb29raWVOYW1lOiBzdHJpbmcsIHZhbHVlOiBzdHJpbmcsIG1heEFnZTogbnVtYmVyLCBwYXRoOiBzdHJpbmcgPSBcIi9cIiwgc2VjdXJlOiBib29sZWFuID0gdHJ1ZSk9PntcclxuICAgIGRvY3VtZW50LmNvb2tpZSA9IGAke2Nvb2tpZU5hbWV9PSR7dmFsdWV9O3BhdGg9JHtwYXRofTttYXgtYWdlPSR7bWF4QWdlfWBcclxufVxyXG5cclxuZXhwb3J0IGNvbnN0IEdldENvb2tpZSA9IChjb29raWVOYW1lOiBzdHJpbmcpOnN0cmluZyB8IHVuZGVmaW5lZD0+e1xyXG4gICAgY29uc3Qgc2VsZWN0ZWRDb29raWUgPSBkb2N1bWVudC5jb29raWUuc3BsaXQoXCI7XCIpLm1hcChjb29raWU9PmNvb2tpZS50cmltKCkpLmZpbHRlcihjb29raWU9PmNvb2tpZS5zdGFydHNXaXRoKGNvb2tpZU5hbWUpKVswXVxyXG4gICAgaWYoc2VsZWN0ZWRDb29raWUpe1xyXG4gICAgICAgIHJldHVybiBzZWxlY3RlZENvb2tpZS5zcGxpdChcIj1cIilbMV1cclxuICAgIH1cclxuICAgIHJldHVybiB1bmRlZmluZWRcclxufVxyXG5cclxuaW50ZXJmYWNlIENhbGVuZGFyQXJyYXl7XHJcbiAgICBjYWxlbmRhcjoge2lzQ3VycmVudE1vbnRoOiBib29sZWFuLCBkYXlOdW1iZXI6IG51bWJlciwgbW9udGg6IG51bWJlcn1bXSxcclxuICAgIHRvOiBzdHJpbmdcclxuICAgIGZyb206IHN0cmluZ1xyXG59IFxyXG5cclxuZXhwb3J0IGNvbnN0IEdldE1vbnRoQXJyYXkgPSAoeWVhcjogbnVtYmVyLCBtb250aEluZGV4OiBudW1iZXIpOkNhbGVuZGFyQXJyYXk9PntcclxuICAgIGNvbnN0IG1vbnRoQXJyYXkgPSBuZXcgQXJyYXkoNDIpLmZpbGwoMClcclxuICAgIGNvbnN0IGRheUFtb3VudCA9IEdldFllYXJEYXlzKHllYXIsIG1vbnRoSW5kZXgpXHJcbiAgICBsZXQgdG86IHN0cmluZyAgPSBgJHt5ZWFyfS0ke21vbnRoSW5kZXggPCAxMCA/IFwiMFwiK21vbnRoSW5kZXggOiBtb250aEluZGV4LnRvU3RyaW5nKCl9LSR7ZGF5QW1vdW50Lm1vbnRoRGF5cy50b1N0cmluZygpfWBcclxuICAgIGxldCBmcm9tOiBzdHJpbmcgPSBgJHt5ZWFyfS0ke21vbnRoSW5kZXggPCAxMCA/IFwiMFwiK21vbnRoSW5kZXggOiBtb250aEluZGV4LnRvU3RyaW5nKCl9LSR7ZGF5QW1vdW50Lm1vbnRoRGF5cy50b1N0cmluZygpfWBcclxuICAgIGNvbnN0IGNhbGVuZGFyID0gbW9udGhBcnJheS5tYXAoKF8sIGluZGV4KTp7aXNDdXJyZW50TW9udGg6IGJvb2xlYW4sIGRheU51bWJlcjogbnVtYmVyLCBtb250aDogbnVtYmVyfT0+e1xyXG4gICAgICAgIGNvbnN0IHRoaXNNb250aCA9IG5ldyBEYXRlKHllYXIsIG1vbnRoSW5kZXgsIDApXHJcbiAgICAgICAgbGV0IGRheU51bWJlciA9IDBcclxuICAgICAgICBsZXQgaXNDdXJyZW50TW9udGggPSBmYWxzZVxyXG4gICAgICAgIGxldCBtb250aCA9IG1vbnRoSW5kZXhcclxuICAgICAgICBpZihpbmRleCsxID4gdGhpc01vbnRoLmdldERheSgpICYmIGluZGV4LXRoaXNNb250aC5nZXREYXkoKSA8IGRheUFtb3VudC5tb250aERheXMpe1xyXG4gICAgICAgICAgICBkYXlOdW1iZXIgPSBpbmRleCsxLXRoaXNNb250aC5nZXREYXkoKVxyXG4gICAgICAgICAgICBpc0N1cnJlbnRNb250aCA9IHRydWVcclxuICAgICAgICAgICAgbW9udGggPSBtb250aEluZGV4XHJcbiAgICAgICAgfWVsc2UgaWYoaW5kZXgtdGhpc01vbnRoLmdldERheSgpID49IGRheUFtb3VudC5tb250aERheXMpe1xyXG4gICAgICAgICAgICBjb25zdCBuZXh0TW9udGggPSBkYXlBbW91bnQubW9udGhJbmRleCA9PT0gMTEgPyBHZXRZZWFyRGF5cyh5ZWFyKzEsIDApIDogR2V0WWVhckRheXMoeWVhciwgZGF5QW1vdW50Lm1vbnRoSW5kZXggKyAxKVxyXG4gICAgICAgICAgICBkYXlOdW1iZXIgPSBpbmRleCsxIC0gdGhpc01vbnRoLmdldERheSgpIC0gZGF5QW1vdW50Lm1vbnRoRGF5c1xyXG4gICAgICAgICAgICBpc0N1cnJlbnRNb250aCA9IGZhbHNlXHJcbiAgICAgICAgICAgIG1vbnRoID0gbmV4dE1vbnRoLm1vbnRoSW5kZXhcclxuICAgICAgICAgICAgaWYgKGluZGV4ID09PSA0MSl7XHJcbiAgICAgICAgICAgICAgICB0byA9IGAke25leHRNb250aC55ZWFyfS0keyhuZXh0TW9udGgubW9udGhJbmRleCArIDEpIDwgMTAgPyBcIjBcIisobmV4dE1vbnRoLm1vbnRoSW5kZXggKyAxKSAgOiAobmV4dE1vbnRoLm1vbnRoSW5kZXggKyAxKS50b1N0cmluZygpfS0ke2RheU51bWJlciA8IDEwID8gXCIwXCIrZGF5TnVtYmVyIDogZGF5TnVtYmVyLnRvU3RyaW5nKCl9YFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfWVsc2V7XHJcbiAgICAgICAgICAgIGNvbnN0IGxhc3RNb250aCA9IGRheUFtb3VudC5tb250aEluZGV4ID09PSAwID8gR2V0WWVhckRheXMoeWVhci0xLCAxMSkgOiBHZXRZZWFyRGF5cyh5ZWFyLCBkYXlBbW91bnQubW9udGhJbmRleCAtIDEpXHJcbiAgICAgICAgICAgIGRheU51bWJlciA9IGxhc3RNb250aC5tb250aERheXMgLSB0aGlzTW9udGguZ2V0RGF5KCkgKyBpbmRleCArMVxyXG4gICAgICAgICAgICBpc0N1cnJlbnRNb250aCA9IGZhbHNlXHJcbiAgICAgICAgICAgIG1vbnRoID0gbGFzdE1vbnRoLm1vbnRoSW5kZXhcclxuICAgICAgICAgICAgaWYgKGluZGV4ID09PSAwKXtcclxuICAgICAgICAgICAgICAgIGZyb20gPSBgJHtsYXN0TW9udGgueWVhcn0tJHsobGFzdE1vbnRoLm1vbnRoSW5kZXgrMSkgPCAxMCA/IFwiMFwiKyhsYXN0TW9udGgubW9udGhJbmRleCsxKSA6IChsYXN0TW9udGgubW9udGhJbmRleCsxKS50b1N0cmluZygpfS0ke2RheU51bWJlciA8IDEwID8gXCIwXCIrZGF5TnVtYmVyIDogZGF5TnVtYmVyLnRvU3RyaW5nKCl9YCBcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4ge2lzQ3VycmVudE1vbnRoLCBkYXlOdW1iZXIsIG1vbnRofSAgICAgICAgICAgIFxyXG4gICAgfSlcclxuICAgIHJldHVybiB7Y2FsZW5kYXIsIHRvLCBmcm9tfVxyXG59XHJcblxyXG50eXBlIFllczxUIGV4dGVuZHMge30+ID0ge1xyXG4gICAgW0tleSBpbiBrZXlvZiBUXTogYW55XHJcbn1cclxuXHJcbmV4cG9ydCBjb25zdCBoYXNDaGFuZ2VkID0gPFRPYmogZXh0ZW5kcyB7fSwgS2V5IGV4dGVuZHMga2V5b2YgVE9iaj4oaW5pdGlhbEFycmF5OiBUT2JqW10sIGNvbXBhcmVUbzogVE9ialtdLCBwcm9wZXJ0aWVzOiBLZXlbXSk6W2Jvb2xlYW4sIFNoaWZ0VHlwZXNbXV09PntcclxuICAgIGNvbnN0IGNoYW5nZXM6IGFueSA9IFtdXHJcbiAgICBmb3IobGV0IGkgPSAwOyBpIDwgaW5pdGlhbEFycmF5Lmxlbmd0aDsgaSsrKXtcclxuICAgICAgICBmb3IobGV0IHggPSAwOyB4IDwgcHJvcGVydGllcy5sZW5ndGg7IHgrKyl7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGNvbXBhcmVUb1tpXSlcclxuICAgICAgICAgICAgaWYoaW5pdGlhbEFycmF5W2ldW3Byb3BlcnRpZXNbeF1dICE9PSBjb21wYXJlVG9baV1bcHJvcGVydGllc1t4XV0pIHJldHVybiBbdHJ1ZSwgY2hhbmdlcy5wdXNoKGNvbXBhcmVUb1tpXSldXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIFtmYWxzZSwgW11dXHJcbn1cclxuIl0sIm5hbWVzIjpbIk1PTlRIX0RBWVMiLCJNT05USFMiLCJHZXRZZWFyRGF5cyIsInllYXIiLCJtb250aCIsIm1vbnRoRGF5cyIsIm1vbnRoSW5kZXgiLCJNT05USCIsIkNyZWF0ZUNvb2tpZSIsImNvb2tpZU5hbWUiLCJ2YWx1ZSIsIm1heEFnZSIsInBhdGgiLCJzZWN1cmUiLCJkb2N1bWVudCIsImNvb2tpZSIsIkdldENvb2tpZSIsInNlbGVjdGVkQ29va2llIiwic3BsaXQiLCJtYXAiLCJ0cmltIiwiZmlsdGVyIiwic3RhcnRzV2l0aCIsInVuZGVmaW5lZCIsIkdldE1vbnRoQXJyYXkiLCJtb250aEFycmF5IiwiQXJyYXkiLCJmaWxsIiwiZGF5QW1vdW50IiwidG8iLCJ0b1N0cmluZyIsImZyb20iLCJjYWxlbmRhciIsIl8iLCJpbmRleCIsInRoaXNNb250aCIsIkRhdGUiLCJkYXlOdW1iZXIiLCJpc0N1cnJlbnRNb250aCIsImdldERheSIsIm5leHRNb250aCIsImxhc3RNb250aCIsImhhc0NoYW5nZWQiLCJpbml0aWFsQXJyYXkiLCJjb21wYXJlVG8iLCJwcm9wZXJ0aWVzIiwiY2hhbmdlcyIsImkiLCJsZW5ndGgiLCJ4IiwiY29uc29sZSIsImxvZyIsInB1c2giXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-client)/./util/lib.ts\n"));

/***/ })

});